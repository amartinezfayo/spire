package disk

import (
	"context"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/hcl"
	configv1 "github.com/spiffe/spire-plugin-sdk/proto/spire/service/common/config/v1"
	"github.com/spiffe/spire/pkg/agent/plugin/svidstore"
	"github.com/spiffe/spire/pkg/common/catalog"
	"github.com/spiffe/spire/pkg/common/telemetry"
	svidstorev1 "github.com/spiffe/spire/proto/spire/plugin/agent/svidstore/v1"
	"go.uber.org/multierr"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const (
	pluginName = "disk"

	// Workloads need to browse through the base directory
	// that has subdirectories for multiple workloads,
	// so others need execute permission in the base dir
	permDirBase = 0751

	// No execute access for Others in the specific
	// directory for the workload
	permSubDir = 0750

	// Workloads need to read the files
	permFile = 0640

	defaultCertChainFileName = "certchain.crt"
	defaultKeyFileName       = "key.key"
	defaultBundleFileName    = "bundle.crt"
)

type diskStore struct {
	certChain svidFile
	key       svidFile
	bundle    svidFile
	groupID   int
}

type svidFile struct {
	filePath string
	pemBytes []byte
}

func (d *diskStore) write(log hclog.Logger) (err error) {
	// cleanupDir is the directory that must be cleaned up when this function
	// finishes. In case that there is an error, the new auto-generated folder
	// containing the files that are being written is cleaned up. If all the
	// files are written successfully, the old directory that has the previous
	// files is removed.
	var cleanupDir string

	// Defer a function that cleanups the files that are no
	// longer used.
	defer func() {
		if removeAllErr := os.RemoveAll(cleanupDir); removeAllErr != nil {
			log.Error("Failed to remove directory", "cleanup_dir", cleanupDir, "error", removeAllErr)
		}
	}()

	// In order to be able to write the files atomically, the files will be
	// written to an auto-generated directory. Once all the files are written
	// in that directory, a symbolic link from the original directory
	// to the generated directory is created.

	// originalDir is the original directory, where the symbolic link will
	// be created.
	originalDir, err := filepath.Abs(filepath.Dir(d.certChain.filePath))
	if err != nil {
		return status.Errorf(codes.Internal, "failed to get absolute path: %v", err)
	}

	// If needed, create the parent directory that will contain the
	// autogenerated directory and the symbolic link.
	parentDir := filepath.Dir(originalDir)
	if err := createDirectoryIfNeeded(parentDir); err != nil {
		return err
	}

	if err := os.Chmod(parentDir, permDirBase); err != nil {
		return status.Errorf(codes.Internal, "failed to change the mode of directory: %v", err)
	}

	// Create a directory with an auto-generated name.
	autoGeneratedDir, err := ioutil.TempDir(parentDir, "*-svid")
	if err != nil {
		return status.Errorf(codes.Internal, "failed to create auto-generated directory: %v", err)
	}

	// The operation of writing the files to the auto-generated
	// directory is not completed. If there is an error before
	// finishing writing all the files, the directory must be
	// cleaned up.
	cleanupDir = autoGeneratedDir

	log.Debug("Changing group ownership of directory", "dir", autoGeneratedDir, "group_id", d.groupID)
	if err := os.Chown(autoGeneratedDir, -1, d.groupID); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of directory: %v", err)
	}
	if err := os.Chmod(autoGeneratedDir, permSubDir); err != nil {
		return status.Errorf(codes.Internal, "failed to change the mode of autogenerated directory: %v", err)
	}

	// Write the files
	certChainFile := filepath.Join(autoGeneratedDir, filepath.Base(d.certChain.filePath))
	log.With("cert_chain_file_path", certChainFile).Debug("Writing certificate chain file")
	if err := os.WriteFile(certChainFile, d.certChain.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write certificate chain file: %v", err)
	}
	if err := os.Chown(certChainFile, -1, d.groupID); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of cert chain file: %v", err)
	}

	keyFile := filepath.Join(autoGeneratedDir, filepath.Base(d.key.filePath))
	log.With("key_file_path", keyFile).Debug("Writing key file")
	if err := os.WriteFile(keyFile, d.key.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write key file %q: %v", keyFile, err)
	}
	if err := os.Chown(keyFile, -1, d.groupID); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of key file: %v", err)
	}

	bundleFile := filepath.Join(autoGeneratedDir, filepath.Base(d.bundle.filePath))
	log.With("bundle_file_path", bundleFile).Debug("Writing bundle file")
	if err := os.WriteFile(bundleFile, d.bundle.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write bundle file %q: %v", bundleFile, err)
	}
	if err := os.Chown(bundleFile, -1, d.groupID); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of bundle file: %v", err)
	}

	// Before updating the symbolic link, read the current link
	// to get the previous auto-generated directory if exists.
	// This will allow us to cleanup the old directory after the
	// symbolic link is updated.
	oldPath, err := os.Readlink(originalDir)
	if err != nil && !os.IsNotExist(err) {
		return status.Errorf(codes.Internal, "failed to read symbolic link: %v", err)
	}

	// Updating the symbolic link must also be done atomically.
	// To do that, we first create a temporary symbolic link and
	// then rename it over the original.
	symlinkPathTmp := originalDir + ".tmp"
	if err := os.Remove(symlinkPathTmp); err != nil && !os.IsNotExist(err) {
		return status.Errorf(codes.Internal, "failed to remove temporary symbolic link: %v", err)
	}
	if err := os.Symlink(autoGeneratedDir, symlinkPathTmp); err != nil {
		return status.Errorf(codes.Internal, "failed to create symbolic link: %v", err)
	}

	if err := os.Rename(symlinkPathTmp, originalDir); err != nil {
		return status.Errorf(codes.Internal, "failed to rename symbolic link: %v", err)
	}
	if err := os.Chown(originalDir, -1, d.groupID); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of symbolik link: %v", err)
	}

	// Since all the files have been written and the
	// symbolic link has been updated, this old auto-generated
	// directory is now the directory that must be cleaned up.
	// Oldpath will be empty in case that there wasn't a symbolic
	// link and no cleanup is needed.
	cleanupDir = oldPath

	return nil
}

func (c *svidFile) delete() error {
	return os.Remove(c.filePath)
}

func BuiltIn() catalog.BuiltIn {
	return builtin(New())
}

func builtin(p *DiskPlugin) catalog.BuiltIn {
	return catalog.MakeBuiltIn(pluginName,
		svidstorev1.SVIDStorePluginServer(p),
		configv1.ConfigServiceServer(p),
	)
}

func New() *DiskPlugin {
	return &DiskPlugin{}
}

type configuration struct {
	BaseDir string `hcl:"base_dir" json:"base_dir"`
}

type DiskPlugin struct {
	svidstorev1.UnsafeSVIDStoreServer
	configv1.UnsafeConfigServer

	log         hclog.Logger
	config      *configuration
	trustDomain string
	mtx         sync.RWMutex
}

// SetLogger sets the logger used by the plugin
func (p *DiskPlugin) SetLogger(log hclog.Logger) {
	p.log = log
}

// Configure configures the plugin
func (p *DiskPlugin) Configure(ctx context.Context, req *configv1.ConfigureRequest) (*configv1.ConfigureResponse, error) {
	config := &configuration{}
	if err := hcl.Decode(config, req.HclConfiguration); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "unable to decode configuration: %v", err)
	}
	if config.BaseDir == "" {
		return nil, status.Error(codes.InvalidArgument, "a base directory must be configured")
	}

	p.mtx.Lock()
	defer p.mtx.Unlock()

	p.trustDomain = req.CoreConfiguration.TrustDomain
	p.config = config

	return &configv1.ConfigureResponse{}, nil
}

// PutX509SVID stores the specified X509-SVID in the configured location
func (p *DiskPlugin) PutX509SVID(ctx context.Context, req *svidstorev1.PutX509SVIDRequest) (*svidstorev1.PutX509SVIDResponse, error) {
	log := p.log.With(telemetry.SPIFFEID, req.Svid.SpiffeID)

	config, err := p.getConfig()
	if err != nil {
		return nil, err
	}

	diskStore, err := newDiskStore(req.Metadata, config.BaseDir)
	if err != nil {
		return nil, err
	}

	diskStore.certChain.pemBytes = certChainPEMBytes(req.Svid.CertChain)
	diskStore.key.pemBytes = keyPEMBytes(req.Svid.PrivateKey)
	diskStore.bundle.pemBytes = certChainPEMBytes(req.Svid.Bundle)
	if err := diskStore.write(log); err != nil {
		return nil, err
	}

	return &svidstorev1.PutX509SVIDResponse{}, nil
}

// DeleteX509SVID deletes the specified stored X509-SVID
func (p *DiskPlugin) DeleteX509SVID(ctx context.Context, req *svidstorev1.DeleteX509SVIDRequest) (*svidstorev1.DeleteX509SVIDResponse, error) {
	config, err := p.getConfig()
	if err != nil {
		return nil, err
	}
	diskStore, err := newDiskStore(req.Metadata, config.BaseDir)
	if err != nil {
		return nil, err
	}

	if errRemoveCertChain := diskStore.certChain.delete(); errRemoveCertChain != nil {
		if os.IsNotExist(errRemoveCertChain) {
			p.log.With("file_path", diskStore.certChain.filePath).Warn("Could not delete certificate chain file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete certificate chain file: %w", errRemoveCertChain))
		}
	}
	if errRemoveKey := diskStore.key.delete(); errRemoveKey != nil {
		if os.IsNotExist(errRemoveKey) {
			p.log.With("file_path", diskStore.key.filePath).Warn("Could not delete key file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete key file: %w", errRemoveKey))
		}
	}
	if errRemoveBundle := diskStore.bundle.delete(); errRemoveBundle != nil {
		if os.IsNotExist(errRemoveBundle) {
			p.log.With("file_path", diskStore.bundle.filePath).Warn("Could not delete bundle file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete bundle file: %w", errRemoveBundle))
		}
	}

	if err != nil {
		return nil, status.Errorf(codes.Internal, "error deleting SVID: %v", err)
	}

	return &svidstorev1.DeleteX509SVIDResponse{}, nil
}

func (p *DiskPlugin) getConfig() (*configuration, error) {
	p.mtx.RLock()
	defer p.mtx.RUnlock()
	if p.config == nil {
		return nil, status.Error(codes.FailedPrecondition, "not configured")
	}
	return p.config, nil
}

func getFileMetadata(metadataMap map[string]string, key string) (string, error) {
	value := metadataMap[key]
	if strings.Contains(value, string(filepath.Separator)) {
		return "", status.Errorf(codes.InvalidArgument, `invalid %q: must be a file name, not a file path`, key)
	}

	return value, nil
}

func newDiskStore(metaData []string, baseDir string) (*diskStore, error) {
	metadataMap, err := svidstore.ParseMetadata(metaData)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing metadata: %v", err)
	}

	subDir := metadataMap["sub_dir"]
	if subDir == "" {
		return nil, status.Error(codes.InvalidArgument, "sub_dir must be specified")
	}
	if containsDotDot(subDir) {
		return nil, status.Errorf(codes.InvalidArgument, `invalid subdir: cannot contain ".."`)
	}
	subDirAbs, err := filepath.Abs(filepath.Join(baseDir, subDir))
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to get absolute path: %v", err)
	}

	certChainFileName, err := getFileMetadata(metadataMap, "cert_chain_file")
	if err != nil {
		return nil, err
	}
	if certChainFileName == "" {
		certChainFileName = defaultCertChainFileName
	}

	keyFileName, err := getFileMetadata(metadataMap, "key_file")
	if err != nil {
		return nil, err
	}
	if keyFileName == "" {
		keyFileName = defaultKeyFileName
	}

	bundleFileName, err := getFileMetadata(metadataMap, "bundle_file")
	if err != nil {
		return nil, err
	}
	if bundleFileName == "" {
		bundleFileName = defaultBundleFileName
	}

	var groupIDInt int64

	groupID := metadataMap["group_id"]
	groupName := metadataMap["group_name"]

	switch {
	case groupID != "" && groupName != "":
		return nil, status.Error(codes.InvalidArgument, "either group_id or group_name must be specified, not both")
	case groupID == "" && groupName == "":
		return nil, status.Error(codes.InvalidArgument, "either group_id or group_name must be specified")
	case groupID != "":
		g, err := user.LookupGroupId(groupID)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to look up group ID: %v", err)
		}
		if groupIDInt, err = strconv.ParseInt(g.Gid, 10, 0); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to parse group ID: %v", err)
		}
	case groupName != "":
		g, err := user.LookupGroup(groupName)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to look up group name: %v", err)
		}
		if groupIDInt, err = strconv.ParseInt(g.Gid, 10, 0); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to parse group ID: %v", err)
		}
	}

	return &diskStore{
		certChain: svidFile{filePath: filepath.Join(subDirAbs, certChainFileName)},
		key:       svidFile{filePath: filepath.Join(subDirAbs, keyFileName)},
		bundle:    svidFile{filePath: filepath.Join(subDirAbs, bundleFileName)},
		groupID:   int(groupIDInt),
	}, nil
}

func createDirectoryIfNeeded(dir string) error {
	if _, statErr := os.Stat(dir); os.IsNotExist(statErr) {
		if err := os.MkdirAll(dir, permDirBase); err != nil {
			return status.Errorf(codes.Internal, "error creating directory: %v", err)
		}
	}

	return nil
}

func keyPEMBytes(privateKey []byte) (pemData []byte) {
	b := &pem.Block{
		Type:  "PRIVATE KEY",
		Bytes: privateKey,
	}

	return pem.EncodeToMemory(b)
}

func certChainPEMBytes(certChain [][]byte) (pemData []byte) {
	for _, cert := range certChain {
		b := &pem.Block{
			Type:  "CERTIFICATE",
			Bytes: cert,
		}
		pemData = append(pemData, pem.EncodeToMemory(b)...)
	}

	return pemData
}

func containsDotDot(v string) bool {
	if !strings.Contains(v, "..") {
		return false
	}
	for _, ent := range strings.FieldsFunc(v, isSlashRune) {
		if ent == ".." {
			return true
		}
	}
	return false
}

func isSlashRune(r rune) bool { return r == '/' || r == '\\' }
