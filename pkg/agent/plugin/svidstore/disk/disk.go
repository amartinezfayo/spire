package disk

import (
	"context"
	"encoding/pem"
	"fmt"
	"io/fs"
	"io/ioutil"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"strings"
	"sync"

	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/hcl"
	configv1 "github.com/spiffe/spire-plugin-sdk/proto/spire/service/common/config/v1"
	"github.com/spiffe/spire/pkg/agent/plugin/svidstore"
	"github.com/spiffe/spire/pkg/common/catalog"
	"github.com/spiffe/spire/pkg/common/telemetry"
	svidstorev1 "github.com/spiffe/spire/proto/spire/plugin/agent/svidstore/v1"
	"go.uber.org/multierr"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const (
	pluginName = "disk"
	permDir    = 0750
	permFile   = 0640
)

type diskStore struct {
	certChain  svidFile
	key        svidFile
	bundle     svidFile
	gid        int
	cleanupDir string // Directory that must be cleaned up after running the write function
}

type svidFile struct {
	filePath string
	pemBytes []byte
}

func (d *diskStore) write(log hclog.Logger) (err error) {
	// Defer a function that cleanups the files that are no
	// longer used.
	defer func() {
		if removeAllErr := os.RemoveAll(d.cleanupDir); removeAllErr != nil {
			log.Error("Failed to remove directory", "cleanup_dir", d.cleanupDir, "error", removeAllErr)
		}
	}()

	// In order to be able to write the files atomically, the files will be
	// written to an auto-generated directory. Once all the files are written
	// in that directory, a symbolic link from the original directory
	// to the generated directory is created.

	// originalDir is the original directory, where the symbolic link will
	// be created.
	originalDir, err := filepath.Abs(filepath.Dir(d.certChain.filePath))
	if err != nil {
		return fmt.Errorf("failed to get absolute path: %w", err)
	}

	// If needed, create the parent directory that will contain the
	// autogenerated directory and the symbolic link.
	parentDir := filepath.Dir(originalDir)
	if err := createDirectoryIfNeeded(parentDir); err != nil {
		return err
	}

	if err := os.Chmod(parentDir, permDir|fs.ModeSetgid); err != nil {
		return fmt.Errorf("failed to change the mode of directory: %w", err)
	}

	if err := os.Chown(parentDir, -1, d.gid); err != nil {
		return status.Errorf(codes.Internal, "failed to change group ownership of directory: %v", err)
	}

	// Create a directory with an auto-generated name.
	autoGeneratedDir, err := ioutil.TempDir(parentDir, "*-svid")
	if err != nil {
		return fmt.Errorf("failed to create auto-generated directory: %w", err)
	}
	if err := os.Chmod(autoGeneratedDir, permDir|fs.ModeSetgid); err != nil {
		return fmt.Errorf("failed to change the mode of autogenerated directory: %w", err)
	}

	// The operation of writing the files to the auto-generated
	// directory is not completed. If there is an error before
	// finishing writing all the files, the directory must be
	// cleaned up.
	d.cleanupDir = autoGeneratedDir

	// Write the files
	certChainFile := filepath.Join(autoGeneratedDir, filepath.Base(d.certChain.filePath))
	log.With("cert_chain_file_path", certChainFile).Debug("Writing certificate chain file")
	if err := os.WriteFile(certChainFile, d.certChain.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write certificate chain file: %v", err)
	}

	keyFile := filepath.Join(autoGeneratedDir, filepath.Base(d.key.filePath))
	log.With("key_file_path", keyFile).Debug("Writing key file")
	if err := os.WriteFile(keyFile, d.key.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write key file %q: %v", keyFile, err)
	}

	bundleFile := filepath.Join(autoGeneratedDir, filepath.Base(d.bundle.filePath))
	log.With("bundle_file_path", bundleFile).Debug("Writing bundle file")
	if err := os.WriteFile(bundleFile, d.bundle.pemBytes, permFile); err != nil {
		return status.Errorf(codes.Internal, "failed to write bundle file %q: %v", bundleFile, err)
	}

	// Before updating the symbolic link, read the current link
	// to get the previous auto-generated directory if exists.
	// This will allow us to cleanup the old directory after the
	// symbolic link is updated.
	oldPath, err := os.Readlink(originalDir)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to read symbolic link: %w", err)
	}

	// Updating the symbolic link must also be done atomically.
	// To do that, we first create a temporary symbolic link and
	// then rename it over the original.
	symlinkPathTmp := originalDir + ".tmp"
	if err := os.Remove(symlinkPathTmp); err != nil && !os.IsNotExist(err) {
		return status.Errorf(codes.Internal, "failed to remove temporary symbolic link: %v", err)
	}
	if err := os.Symlink(autoGeneratedDir, symlinkPathTmp); err != nil {
		return status.Errorf(codes.Internal, "failed to create symbolic link: %v", err)
	}

	if err := os.Rename(symlinkPathTmp, originalDir); err != nil {
		return status.Errorf(codes.Internal, "failed to rename symbolic link: %v", err)
	}

	if oldPath != "" {
		// There was a symbolic link pointing to an old auto-generated
		// directory. Since all the files have been written and the
		// symbolic link has been updated, this old auto-generated
		// directory is now the directory that must be cleaned up.
		d.cleanupDir = oldPath
	} else {
		// There wasn't a symbolic link. Since all the files have been
		// written at this point, no cleanup is needed.
		d.cleanupDir = ""
	}

	return nil
}

func (c *svidFile) delete() error {
	return os.Remove(c.filePath)
}

func BuiltIn() catalog.BuiltIn {
	return builtin(New())
}

func builtin(p *DiskPlugin) catalog.BuiltIn {
	return catalog.MakeBuiltIn(pluginName,
		svidstorev1.SVIDStorePluginServer(p),
		configv1.ConfigServiceServer(p),
	)
}

func New() *DiskPlugin {
	return &DiskPlugin{}
}

type configuration struct {
	Directory string `hcl:"directory" json:"directory"`
}

type DiskPlugin struct {
	svidstorev1.UnsafeSVIDStoreServer
	configv1.UnsafeConfigServer

	log         hclog.Logger
	config      *configuration
	trustDomain string
	mtx         sync.RWMutex
}

// SetLogger sets the logger used by the plugin
func (p *DiskPlugin) SetLogger(log hclog.Logger) {
	p.log = log
}

// Configure configures the plugin
func (p *DiskPlugin) Configure(ctx context.Context, req *configv1.ConfigureRequest) (*configv1.ConfigureResponse, error) {
	config := &configuration{}
	if err := hcl.Decode(config, req.HclConfiguration); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "unable to decode configuration: %v", err)
	}
	if config.Directory == "" {
		return nil, status.Error(codes.InvalidArgument, "a directory must be configured")
	}

	p.mtx.Lock()
	defer p.mtx.Unlock()

	p.trustDomain = req.CoreConfiguration.TrustDomain
	p.config = config

	return &configv1.ConfigureResponse{}, nil
}

// PutX509SVID stores the specified X509-SVID in the configured location
func (p *DiskPlugin) PutX509SVID(ctx context.Context, req *svidstorev1.PutX509SVIDRequest) (*svidstorev1.PutX509SVIDResponse, error) {
	log := p.log.With(telemetry.SPIFFEID, req.Svid.SpiffeID)

	config, err := p.getConfig()
	if err != nil {
		return nil, err
	}

	diskStore, err := newDiskStore(req.Metadata, config.Directory)
	if err != nil {
		return nil, err
	}

	diskStore.certChain.pemBytes = certChainPEMBytes(req.Svid.CertChain)
	diskStore.key.pemBytes = keyPEMBytes(req.Svid.PrivateKey)
	diskStore.bundle.pemBytes = certChainPEMBytes(req.Svid.Bundle)
	if err := diskStore.write(log); err != nil {
		return nil, err
	}

	return &svidstorev1.PutX509SVIDResponse{}, nil
}

// DeleteX509SVID deletes the specified stored X509-SVID
func (p *DiskPlugin) DeleteX509SVID(ctx context.Context, req *svidstorev1.DeleteX509SVIDRequest) (*svidstorev1.DeleteX509SVIDResponse, error) {
	config, err := p.getConfig()
	if err != nil {
		return nil, err
	}
	diskStore, err := newDiskStore(req.Metadata, config.Directory)
	if err != nil {
		return nil, err
	}

	if errRemoveCertChain := diskStore.certChain.delete(); errRemoveCertChain != nil {
		if os.IsNotExist(errRemoveCertChain) {
			p.log.With("file_path", diskStore.certChain.filePath).Warn("Could not delete certificate chain file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete certificate chain file: %w", errRemoveCertChain))
		}
	}
	if errRemoveKey := diskStore.key.delete(); errRemoveKey != nil {
		if os.IsNotExist(errRemoveKey) {
			p.log.With("file_path", diskStore.key.filePath).Warn("Could not delete key file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete key file: %w", errRemoveKey))
		}
	}
	if errRemoveBundle := diskStore.bundle.delete(); errRemoveBundle != nil {
		if os.IsNotExist(errRemoveBundle) {
			p.log.With("file_path", diskStore.bundle.filePath).Warn("Could not delete bundle file. File not found")
		} else {
			err = multierr.Append(err, fmt.Errorf("failed to delete bundle file: %w", errRemoveBundle))
		}
	}

	if err != nil {
		return nil, status.Errorf(codes.Internal, "error deleting SVID: %v", err)
	}

	return &svidstorev1.DeleteX509SVIDResponse{}, nil
}

func (p *DiskPlugin) getConfig() (*configuration, error) {
	p.mtx.RLock()
	defer p.mtx.RUnlock()
	if p.config == nil {
		return nil, status.Error(codes.FailedPrecondition, "not configured")
	}
	return p.config, nil
}

func getFileMetadata(metadataMap map[string]string, key string) (string, error) {
	value := metadataMap[key]
	if value == "" {
		return "", status.Errorf(codes.InvalidArgument, "%q must be specified", key)
	}
	if containsDotDot(value) {
		return "", status.Errorf(codes.InvalidArgument, `invalid %q: cannot contain ".."`, key)
	}

	return value, nil
}

func newDiskStore(metaData []string, baseDir string) (*diskStore, error) {
	metadataMap, err := svidstore.ParseMetadata(metaData)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing metadata: %v", err)
	}

	certChainFilePath, err := getFileMetadata(metadataMap, "certchainfile")
	if err != nil {
		return nil, err
	}

	dir := filepath.Dir(certChainFilePath)
	if dir == "." || dir[0] == filepath.Separator {
		return nil, status.Error(codes.InvalidArgument, "files cannot reside in the base directory")
	}

	keyFilePath, err := getFileMetadata(metadataMap, "keyfile")
	if err != nil {
		return nil, err
	}

	if err := sameDirectory(certChainFilePath, keyFilePath); err != nil {
		return nil, err
	}

	bundleFilePath, err := getFileMetadata(metadataMap, "bundlefile")
	if err != nil {
		return nil, err
	}

	if err := sameDirectory(keyFilePath, bundleFilePath); err != nil {
		return nil, err
	}

	var gidInt int64

	gid := metadataMap["gid"]
	groupName := metadataMap["group"]

	if gid != "" {
		if groupName != "" {
			return nil, status.Error(codes.InvalidArgument, "either gid or group must be specified, not both")
		}
		g, err := user.LookupGroupId(gid)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to look up gid: %v", err)
		}
		if gidInt, err = strconv.ParseInt(g.Gid, 10, 0); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to parse gid: %v", err)
		}
	} else {
		if groupName == "" {
			return nil, status.Error(codes.InvalidArgument, "either gid or group must be specified")
		}
		g, err := user.LookupGroup(groupName)
		if err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to look up group: %v", err)
		}
		if gidInt, err = strconv.ParseInt(g.Gid, 10, 0); err != nil {
			return nil, status.Errorf(codes.InvalidArgument, "failed to parse gid: %v", err)
		}
	}

	return &diskStore{
		certChain: svidFile{filePath: filepath.Join(baseDir, certChainFilePath)},
		key:       svidFile{filePath: filepath.Join(baseDir, keyFilePath)},
		bundle:    svidFile{filePath: filepath.Join(baseDir, bundleFilePath)},
		gid:       int(gidInt),
	}, nil
}

func createDirectoryIfNeeded(dir string) error {
	if _, statErr := os.Stat(dir); os.IsNotExist(statErr) {
		if err := os.MkdirAll(dir, permDir|fs.ModeSetgid); err != nil {
			return status.Errorf(codes.Internal, "error creating directory: %v", err)
		}
	}

	return nil
}

func sameDirectory(filePath1, filePath2 string) error {
	if filepath.Dir(filePath1) != filepath.Dir(filePath2) {
		return status.Error(codes.InvalidArgument, "files must be in the same directory")
	}

	return nil
}

func keyPEMBytes(privateKey []byte) (pemData []byte) {
	b := &pem.Block{
		Type:  "PRIVATE KEY",
		Bytes: privateKey,
	}

	return pem.EncodeToMemory(b)
}

func certChainPEMBytes(certChain [][]byte) (pemData []byte) {
	for _, cert := range certChain {
		b := &pem.Block{
			Type:  "CERTIFICATE",
			Bytes: cert,
		}
		pemData = append(pemData, pem.EncodeToMemory(b)...)
	}

	return pemData
}

func containsDotDot(v string) bool {
	if !strings.Contains(v, "..") {
		return false
	}
	for _, ent := range strings.FieldsFunc(v, isSlashRune) {
		if ent == ".." {
			return true
		}
	}
	return false
}

func isSlashRune(r rune) bool { return r == '/' || r == '\\' }
